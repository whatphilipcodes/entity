// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel renderCanvas
//#pragma kernel processPoints

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture

// texture
shared RWTexture2D<float4> Result;
int texResolution;
float4 _pcol;

// buffer
StructuredBuffer<float2> pointsBuffer;
RWStructuredBuffer<float2> pixelsBuffer;

// Returns pseudo random number in range 0 <= x < 1
float random(float value, float seed = 0.546){
	float random = (frac(sin(value + seed) * 143758.5453));// + 1.0)/2.0;
	return random;
}

float2 random2(float value){
	return float2(
		random(value, 3.9812),
		random(value, 7.1536)
	);
}
///////////////

// Line Segment Functions (NedMakesGames)
#ifndef LINE_SEGMENT_2D_SDF_DEFINED
#define LINE_SEGMENT_2D_SDF_DEFINED
float LineSegment2DSDF(float2 p, float2 a, float2 b)
{
    float2 ba = b - a;
    float2 pa = p - a;
    float k = saturate(dot(pa, ba) / dot(ba, ba));
    return length(pa - ba * k);
}
#endif

float DrawLine(float2 i, float2 a, float2 b, float thick, float crisp)
{
    float ct = thick + crisp;
    float d = LineSegment2DSDF(i,a,b);
    float o = smoothstep(thick, ct, d);
    return 1 - o;
}
///////////////

/*
[numthreads(64,1,1)]
void processPoints (uint3 id : SV_DISPATCHTHREADID)
{

}
*/
[numthreads(64,1,1)] // x*y*z must be < 1024
void renderCanvas (uint3 id : SV_DispatchThreadID)
{
    /*
    float l = DrawLine(id.xy, linesBuffer[id.z]._start, linesBuffer[id.z]._end, _thick, _crisp);
    if (l > 0) Result[id.xy] = lerp(float4(0,0,0,0), _lcol, l);
    */
    Result[pointsBuffer[id.x].xy] = _pcol;
}